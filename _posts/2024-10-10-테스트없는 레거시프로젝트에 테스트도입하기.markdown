---
layout: post
title:  "테스트없는 레거시프로젝트에 테스트 도입하는 이야기"
date:   2024-10-19 00:00:00 +0900
categories: 
---

### 배경: 테스트 코드 부재로 인해 마주친 실무적인 문제

내가 담당하는 프로젝트에는 테스트 코드가 없었다. 회사에서도 아직은 테스트 코드 작성을 요구하지 않았다. 그러나 요구하는 기능과 복잡성이 점점 가중되었고 다음과 같은 문제에 봉착했다. 

- 지금까지는 포스트맨으로 엔드포인트를 테스트 했다. 이 방법은 생산성이 낮았고 테스트 비용이 너무 높기 때문에 더이상 지속할 수 없었다.
- 테스트 코드가 없기 때문에 요구사항의 변경으로 인한 일부 로직의 수정의 사이드 이팩트를 수동으로 평가해야 했다.
- 시간이 지난 후 내가 작성한 코드를 다시 수정하게 되었을 때 코드의 동작을 잘 이해하지 못했다. 만약 테스트 코드가 있었다면 기능을 더 쉽게 파악할 수 있었을 것이다.
- 스스로는 클린한 구조로 코드를 작성했다고 생각했지만 실제로는 그렇지 않았고 이는 시험삼아 작성한 테스트 코드에서 의존성을 주입할 때 드러났다. 즉 테스트 코드를 작성하면서 기존 설계의 문제점을 파악했다. 

  나는 현재 프로젝트에 테스트를 도입하고 자동화해야겠다고 생각했다. 그래서 이에 관련한 여러 자료를 찾아 보게 되었다. 그 때 찾아본 자료들은 대략 다음과 같다.

- [2024년 인프콘 후기 - #4 클린 스프링](https://velog.io/@joshuara7235/2024%EB%85%84-%EC%9D%B8%ED%94%84%EC%BD%98-%ED%9B%84%EA%B8%B0-4-%ED%81%B4%EB%A6%B0-%EC%8A%A4%ED%94%84%EB%A7%81)
- [단위 테스트의 가성비를 10초만에 판단하는 법](https://www.youtube.com/watch?v=qECd2q3USqA)
- [스프링캠프 2019 [Track 2 Session 3] : 무엇을 테스트할 것인가? 어떻게 테스트할 것인가? (권용근)](https://www.youtube.com/watch?v=YdtknE_yPk4)
- [지속 가능한 인수 테스트 주도 개발 #우아콘2023](https://www.youtube.com/watch?v=birVFRb2d-E)
- [[3월 우아한테크세미나] 우아한ATDD](https://www.youtube.com/watch?v=ITVpmjM4mUE)
- [Test Code Why? What? How?](https://kakaoentertainment-tech.tistory.com/78)

### 방법보다 목적과 대상을
테스트를 공부하기 위해서 Junit 책을 읽다가 흥미가 없어서 계속 읽기가 어려웠다. 내면을 고찰하다가 다음과 같은 사실을 알게되었다.

- 세련된 기술이나 방법은 나중에 습득하면 된다. 처음엔 아무 생각없이 @SpringBootTest로 통합으로 시작해도 무방하다.
- 정말 중요한 것은 무엇을 왜 테스트 하는지이다. 이것은 책이나 어디서든 쉽게 알려주지 않는다.
- 쉽게 배울 수 없다는 것은 specific 하지 않고 Abstract 하다는 것이다. 테스트 원칙이나 철학은 Abstract에 해당하고 Concrete, Specific은 실제 업무 환경에서 찾아야 한다.

따라서 나는 책이 지루해질 때까지 공부하고 실제로 실무에 테스트 코드를 도입해면서 배우기로 했다. 나중에 지식이 더 필요할 때 책을 읽으면 더 재밌을 것이다.

### 어떤 테스트를 도입할 것인가?
다양한 Scope의 테스트가 있고 어떤 테스트를 도입할 것인지에 대해서 고민이 되었지만 나는 우선 필요한 테스트를 도입하는 것이 좋겠다고 생각했다. 
- 우선 기능을 구현하면서 보다 작은 단위의 로직을 검증하기 위한 `단위테스트`가 필요했다. 
- 그리고 사용자 시나리오에 따라서 기능 작동을 검증할 `인수테스트`가 필요했다. 
  - 단 E2E의 UI는 포함하지 않고 API를 테스트 하려고 생각했다.
  - UI를 포함하지 않는 테스트를 `인수테스트`라고 부를 수 있을지 고민을 했지만 서버사이드 개발의 종단이 API이기 때문에 많은 사례들이 서버 사이드의 인수테스트를 API까지 테스트하고 있었다. 나는 이를 `서버사이드 인수테스트`라고 구분하면 좋겠다고 생각했다.  [[3월 우아한테크세미나] 우아한ATDD](https://www.youtube.com/watch?v=ITVpmjM4mUE) 

아래는 챗 지피티가 알려준 각 테스트의 차이다.


| **구분**       | **단위 테스트 (Unit Test)**   | **기능 테스트 (Functional Test)**            | **인수 테스트 (Acceptance Test)**                  |
|--------------|--------------------------|-----------------------------------------|-----------------------------------------------|
| **목적**       | 개별 메서드나 클래스의 동작을 검증      | 특정 기능(API나 모듈)이 설계된 대로 동작하는지 검증         | 시스템이 사용자 요구사항을 충족하는지 종합적으로 검증                 |
| **관점**       | 개발자 관점, 코드 수준에서 테스트      | 개발자 관점, 기능 단위로 테스트                      | 사용자 또는 비즈니스 관점, 시스템 전체 테스트                    |
| **테스트 범위**   | 단일 메서드, 클래스, 작은 단위의 모듈   | API, 서비스 등 개별 기능이나 모듈                   | 사용자 시나리오 기반의 전체 흐름(종단 간 테스트)                  |
| **테스트 대상**   | 코드의 개별 요소                | 하나의 기능(예: API 엔드포인트, 서비스 로직)            | 전체 시스템, 여러 기능 간의 상호작용, UI와 데이터 흐름 등           |
| **사용 도구**    | JUnit, Mockito 등         | MockMvc, RestAssured 등                  | RestAssured, Selenium 등(전체 흐름을 테스트하는 도구)      |
| **테스트 속도**   | 매우 빠름                    | 비교적 빠름                                  | 상대적으로 느림 (종단 간 테스트이기 때문에 더 복잡함)               |
| **의존성**      | 테스트 대상 클래스 외에는 의존하지 않음   | API나 모듈이 서로 어떻게 동작하는지 일부 의존성 있음         | 전체 시스템 의존 (데이터베이스, 외부 시스템 등 포함 가능)            |
| **실제 환경 반영** | 실제 환경을 반드시 반영하지 않음       | 일부 실제 환경 반영 가능(Mock 사용 가능)              | 실제 환경과 유사하게 테스트, 데이터베이스와 실제 네트워크 호출 가능        |
| **예시**       | 특정 계산 메서드가 두 숫자를 더하는지 검증 | API 엔드포인트가 올바르게 작동하고, 응답을 예상대로 반환하는지 검증 | 사용자가 로그인하고 상품을 장바구니에 추가한 후 결제까지 완료하는 시나리오 테스트 |


나는 기존의 프로젝트의 레거시들에 테스트 코드가 없기 때문에 현재 개발을 하고 있는 기능에 대해서 우선 API 인수 테스트를 도입하고 특별히 로직이 어렵고 복잡하고 검증이 필요한 경우 단위테스트를 도입하고자 했다.

우선 요구사항에 따라 작성된 API 유즈케이스 시나리오를 작성했고 해당 시나리오에 맞도록 인수테스트를 작성했다. 그리고 상대적으로 로직이 중요한 경우나 API 인수테스트 만으로는 로직의 안정성을 보장할 수 없는 복잡도가 높은 로직의 경우는 단위테스트를 작성하기로 했다.


### 테스트 도입하기 1: 테스트에 필요한 Application Properties로 분리하기
내가 맡은 프로젝트는 application.yml, application-local.yml, application-prod.yml, application-dev.yml 로 각 Stage 마다 설정파일을 구분하고 있다. 

application.yml은 기본으로 공통로드 되는 설정이며 application.yml에 Stage마다 spring.profiles.active={profileName}를 변경해서 다른 설정을 덮어 씌운다.  
보통 Docker로 서버를 올리기 때문에 각 인스턴스의 docker-compose.yml에 해당 설정 값을 변경해서 사용한다. 

 테스트용 설정파일은 src/test/resources/에 위치시킨다. 기본적으로 @SpringBootTest는 자동으로 application.properties 를 로드한다. 내가 쓰는 인텔리제이의 환경에서는 src/test/resources/application.properties 를 찾고 없으면 src/main/resources/application.properties 를 가져온다. 

 따라서 굳이 src/test/resources/ 에 프로퍼티 공통 프로퍼티 파일을 위치시키지 않고 application-test.properties 만 저장해두고 @SpringBootTest(properties = "spring.profiles.active=test")로 테스트용 프로퍼티 파일만 따로 불러오는 것이 좋을 수 있다.  
 이 경우 공통 프로퍼티는 src/main/resources/application.properties 의 전적인 책임으로 맡기고 테스트용 프로퍼티만 명시적으로 애노테이션에서 지정해두는 것으로 메인 공통 프로퍼티의 변경으로 인한 환경 변화를 즉시 테스트 환경에 적용 가능하다.

 만약 테스트 환경의 변화로 `src/main/resources/application.properties` 가 아닌 다른 것을 사용해야 한다면 `src/test/resources/application.properties` 를 새롭게 둘 수 있다. 이런 경우 main 프로퍼티의 변경이 즉시 테스트 환경에 반영되지 않으므로 주의해야한다. 따라서 꼭 구분해둘 것이 아니면 변경된 프로퍼티는 `src/test/resources/application-test.properties` 에 지정해 두는 것이 좋다고 생각한다. 

또한 `@ActiveProfile({profileName})` 을 사용하면 기본 프로퍼티 외 다른 프로퍼티파일을 로드할 수 있다. 하지만 이는 런타임에 애노테이션을 읽고 로드하므로 프로퍼티 변수인 `${spring.profiles.active}`에 값이 지정되지 않는다. 따라서 어플리케이션에서 해당 변수를 사용하여 스프링 빈 등의 configuration이나 초기화를 실행하는 경우 문제가 생길 수 있다. 따라서 이런 경우 테스트 환경구축을 위해서 처음부터 일반적인 운영이나 개발 서버의 동작환경인 `-Dspring.profiles.active` 과 유사하도록 `@SpringBootTest(properties = "spring.profiles.active=")` attribute 를 지정하는 것이 좋다고 생각한다.


> references
>> - [Override default Spring-Boot application.properties settings in Junit Test
](https://stackoverflow.com/questions/29669393/override-default-spring-boot-application-properties-settings-in-junit-test)
>> - [[Spring] @Profile, @ActiveProfiles 에 대해](https://bepoz-study-diary.tistory.com/371)
>> - [Baeldung - Spring Profiles](https://velog.io/@baekrang256/Baeldung-Spring-Profiles)

나는 위에서 공부한 내용을 바탕으로 환경변수 영역에서 실제 서비스 환경과 같은 테스트 환경을 구축했다.

###  테스트 도입하기 2: 테스트 데이터 베이스 환경 선택하기
흔히 데이터 베이스에 대해서 다음과 같은 2가지 방식 중 하나를 고른다.

| 항목           | 로컬 데이터베이스               | 컨테이너 기반 데이터베이스         |
|--------------|-------------------------|------------------------|
| **설치 및 설정**  | 개발자의 로컬 환경에 직접 설치       | Docker 등 컨테이너로 설정 자동화  |
| **환경 일관성**   | 개발자별 환경 차이 발생 가능        | 모든 환경에서 일관성 유지         |
| **속도**       | 설정이 되어 있다면 빠르게 실행 가능    | 컨테이너 생성 및 실행 시간 필요     |
| **자원 관리**    | 개발자 로컬 자원 사용            | 컨테이너에 할당된 자원만 사용       |
| **초기화 용이성**  | 데이터 초기화 및 리셋이 번거로울 수 있음 | 컨테이너 재실행으로 쉽게 초기화 가능   |
| **CI/CD 통합** | 별도의 설정 필요               | 쉽게 통합 가능, 자동화에 유리      |

나는 연습차원에서 둘을 모두 현제 프로젝트에 적용해 보았다. 테스트 컨테이너로 데이터베이스 환경을 구축하는 것은 뚜렷한 장점은 있지만 아직까지 꼭 필요한 기술은 아니었다. 또한 프로젝트의 현재 수준에서는 로컬 환경으로 테스트틑 해보는 것으로 충분했다. 나중에 필요하다면 컨테이너 기반으로 고도화를 할 수도 있을 것이다.

따라서 나는 테스트 데이터베이스 환경 구축을 로컬 데이터 베이스로 결정했다. 

### 테스트 도입하기 3: 픽스쳐의 중요성

 테스트 데이터의 fixture도 또한 중요하다. 일반적으로 특정 기능을 테스트하는 시나리오에는 사전에 준비해야할 것이 많다. 예를 들어 특정 사용자가 게시판에 게시글을 등록하는 기능을 테스트한다면 사용자가 사전에 회원으로 등록되어 있어야 한다. 또한 사용자가 게시글을 작성할 수 있는 권한이 부여되어 있어야 한다. 이전 사전 조건은 흔히 Given. When. Then. 3step behavior 에서 Given에 해당하는 `테스트 환경`이기 때문에 각 테스트 별로 준비해야한다. 일반적으로 When 절은 API를 호출하는 동작이기 때문에 Given이나 Then의 영역이 중점적으로 개발자의 리소스가 투여되는 부분이다. 많은 사례에서도 Fixture에 대한 관리에 대한 어려움을 토로하는 얘기들이 많지만 정작 각 개발자의 속한 프로젝트의 도메인별로 통일된 fixture 관리 방법이 따로 없고 각 상황에 맞추어 준비하는 경우가 대부분이었다. 그럼에도 공통적으로 자주 쓰는 방법이 있는데 1. SQL 스크립트를 테스트 전에 실행하거나 2.Json 또는 Xml과 같은 데이터를 deserialize 하여 POJO fixture로 만들거나 3. Fixture용 클래스를 따로 만들고 각 테스트에서 초기화를 수행 등의 여러 방법이 있다. 여기서 3번인 POJO가 현대적이고 IDE의 도움을 받을 수 있긴 하지만 준비 코드가 장황해지고 실제 테스트 코드의 가독성이 떨어지는 문제도 있다. 이를 도와주는 한 라이브러리가 있다. 그것은 Naver의 최우성 개발자님께서 만드신 Fixture Monkey인데 Fixture Monkey는 리플렉션과 자바표준빈 규약에 따른 Setter 등으로 쉽게 Fixture를 만들어준다. 나중에 fixture관리가 어려워지는 시기에는 도입해볼 예정이다.

### 인수테스트, RestAssured 로 시작하기
인수 테스트는 클라이언트 입장에서의 서버 api 를 테스트한다. 따라서 인터페이스는 프레젠테이션 영역인 웹 영역이 되는데 이 영역을 테스트하기 위한 여러 기술들이 있다 주로 비교되는 것이 MockMvc, TestRestTemplate , RestAssured 그러나 MockMvc는 사실 슬라이스 테스트이기 때문에 제외해야 되는 게 맞으나, 공부를 하는 차원에서 아래의 표와 같이 챗지피티를 이용하여 작성하였다.

| 특성              | MockMvc                              | TestRestTemplate                       | RestAssured                         |
|-----------------|--------------------------------------|----------------------------------------|-------------------------------------|
| **주요 목적**       | 컨트롤러 단위 테스트, 내부 요청 테스트               | 통합 테스트, 전체 애플리케이션 요청                   | 통합 테스트, 실제 HTTP 요청 테스트              |
| **테스트 대상**      | DispatcherServlet을 통한 스프링 MVC 계층 테스트 | 전체 애플리케이션의 컨트롤러와 서비스 계층까지 포함           | 전체 애플리케이션, 실제 네트워크 통신 모사            |
| **실제 서버 필요 여부** | 필요하지 않음 (내부적으로 MVC 호출)               | 필요 (SpringBootTest와 함께 사용 시 내장 서버 구동)  | 필요 (서버가 실제로 구동되어야 함)                |
| **성능**          | 빠름 (내부적으로 실행하므로 네트워크 없음)             | 느림 (내장 서버 구동으로 실제 HTTP 요청)             | 느림 (실제 HTTP 요청을 수행)                 |
| **주요 사용 사례**    | 빠른 피드백이 필요한 컨트롤러 단위 테스트              | 실제 애플리케이션의 통합 테스트 (내장 서버와 함께 사용)       | 외부 API 테스트 또는 실제 HTTP 요청을 통한 통합 테스트 |
| **REST API 지원** | REST API 요청을 모킹하여 처리                 | REST API 요청 가능, HTTP 상태 코드 및 응답 데이터 확인 | REST API 요청 가능, 요청 구성 및 응답 처리 용이    |
| **주요 제한 사항**    | 실제 네트워크 요청 불가, Spring MVC에 종속        | 외부 API 호출 테스트 어려움                      | 내장 서버 필요, 실제 HTTP 요청으로 성능 저하 가능     |
| **설정 및 사용 난이도** | 상대적으로 쉬움 (스프링 컨텍스트 내부 사용)            | 쉬움 (SpringBootTest와 함께 쉽게 사용)          | 다소 복잡 (다양한 설정 옵션 제공)                |
| **추천 상황**       | 컨트롤러 단위 테스트 및 빠른 피드백이 필요할 때          | 전반적인 서비스 통합 테스트, 실제 애플리케이션 테스트 필요할 때   | 외부 API와의 통합 테스트 또는 실제 네트워크 요청 테스트   |


테스트 레스트 템플릿은 아주 구체적인 세부 설정이 가능하지만 조금 복잡하며 가독성이 떨어진다. 그에 비해 RestAssured는 BDD 에 따라서 좀더 가독성이 있는 형태로서 표현되기 좋다. 아래는 RestAssured을 사용하는 예시이다.

```java
@Test
public void getMember() {
    given().
            accept(MediaType.APPLICATION_JSON_VALUE).
    when().
            get("/members/1").
    then().
            log().all().
            statusCode(HttpStatus.OK).
            assertThat().body("id", equalTo(1)); 
}
```

### 테스트 도입하기 4: 도입과정

- 나는 RestAssured 를 인수테스트에 도입하기로 했다.
  - BDD 스타일로 가독성이 좋아 테스트 케이스를 문서화하기 좋았다.
  - ObjectMapper를 사용하지 않더라도 요청과 응답간의 json 역-직렬화를 기본 제공하기 때문에 객체지향적인 Assertion 이 가능하다. 

- 그리고 나는 @AfterEach 메소드에서 전체 테이블에 대해 Trancate를 실시했다.
  - 로컬데이터베이스를 테스트 인프라로 사용하므로 잔존 데이터의 영향을 없고자 했다.
  - 외래키 제약조건을 무시하기 위해 @AfterEach 메소드 마다 제약 검사 기능을 OFF했다. 
  
- 그리고 나는 @BeforeEach 메소드에서 jdbcTemplate로 각 테스트 필요한 시드 데이터를 초기화 했다. 
  - SQL 스크립트 로딩은 사용하지 않았다. 시드 데이터의 양이 적어 외부화시킬 필요가 없었다.
  - Repository 의 Save(Entity) 를 사용하지 않았다. 빌더를 통한 엔티티의 생성은 가독성이 떨어졌기 때문이다.
  - 픽스쳐 몽키나 다른 픽스처를 위한 외부 라이브러리를 사용하지 않았다. 그것을 사용할 만큼 복잡하지 않았기 때문이다.

- 그리고 나는 테스트 시나리오에 따라서 준비돼야 할 갖춰야 할 조건을 만들기 위한 요청을 작은 메소드들로 구성했다 
  - 각 메소드들은 RestAssured을 활용한 단위 API 요청 메소드다. 
  - 각 API요청에 필요한 요청 페이로드나 변수들을 파라미터라이즈 했다 
  - 각 요청을 수행한 결과를 POJO로 받을 수 있도록 메소드를 구성했다.
  - 각 요청이 테스트 시나리오의 따라 단순히 수행되어야만 할 조건이라면 성공 HTTP Status인 200만을 확인하고 넘어가도록 래핑하였다.
  - 경우에 따라서는 모든 시나리오 조건 자체를 JdbcTemplate으로 SQL을 execution 할 수도 있겠지만 여러 API가 시간차를 두고 협동할 때 생길 수 있는 문제를 확인하는게 중요했다.

- 그 테스트 메소드에서 가장 중요하고 확인을 해야 할 요청은 추상화하지 않고 그대로 RestAssured로 작성했다.
  - 메소드 외부파라미터로 파라미터 라이즈 테스트를 하는 경우도 있기 때문에 메소드 안에서 각 입력값이 어떻게 각각 대응되는지 가시적으로 볼 수 있도록 구성했다.