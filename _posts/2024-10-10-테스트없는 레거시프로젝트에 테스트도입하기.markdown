---
layout: post
title:  "테스트없는 레거시프로젝트에 테스트 도입하는 이야기"
date:   2024-10-19 00:00:00 +0900
categories: 
---

### 배경: 테스트 코드 부재로 인해 마주친 실무적인 문제

내가 담당하는 프로젝트에는 테스트 코드가 없었다. 회사에서도 아직은 테스트 코드 작성을 요구하지 않았다. 그러나 요구하는 기능과 복잡성이 점점 가중되었고 다음과 같은 문제에 봉착했다. 

- 지금까지는 포스트맨으로 엔드포인트를 테스트 했다. 이 방법은 생산성이 낮았고 테스트 비용이 너무 높기 때문에 더이상 지속할 수 없었다.
- 테스트 코드가 없기 때문에 요구사항의 변경으로 인한 일부 로직의 수정의 사이드 이팩트를 수동으로 평가해야 했다.
- 시간이 지난 후 내가 작성한 코드를 다시 수정하게 되었을 때 코드의 동작을 잘 이해하지 못했다. 만약 테스트 코드가 있었다면 기능을 더 쉽게 파악할 수 있었을 것이다.
- 스스로는 클린한 구조로 코드를 작성했다고 생각했지만 실제로는 그렇지 않았고 이는 시험삼아 작성한 테스트 코드에서 의존성을 주입할 때 드러났다. 즉 테스트 코드를 작성하면서 기존 설계의 문제점을 파악했다. 

  나는 현재 프로젝트에 테스트를 도입하고 자동화해야겠다고 생각했다. 그래서 이에 관련한 여러 자료를 찾아 보게 되었다. 그 때 찾아본 자료들은 대략 다음과 같다.

- [2024년 인프콘 후기 - #4 클린 스프링](https://velog.io/@joshuara7235/2024%EB%85%84-%EC%9D%B8%ED%94%84%EC%BD%98-%ED%9B%84%EA%B8%B0-4-%ED%81%B4%EB%A6%B0-%EC%8A%A4%ED%94%84%EB%A7%81)
- [단위 테스트의 가성비를 10초만에 판단하는 법](https://www.youtube.com/watch?v=qECd2q3USqA)
- [스프링캠프 2019 [Track 2 Session 3] : 무엇을 테스트할 것인가? 어떻게 테스트할 것인가? (권용근)](https://www.youtube.com/watch?v=YdtknE_yPk4)
- [지속 가능한 인수 테스트 주도 개발 #우아콘2023](https://www.youtube.com/watch?v=birVFRb2d-E)
- [[3월 우아한테크세미나] 우아한ATDD](https://www.youtube.com/watch?v=ITVpmjM4mUE)
- [Test Code Why? What? How?](https://kakaoentertainment-tech.tistory.com/78)

### 방법보다 목적과 대상을
테스트를 공부하기 위해서 Junit 책을 읽다가 흥미가 없어서 계속 읽기가 어려웠다. 내면을 고찰하다가 다음과 같은 사실을 알게되었다.

- 세련된 기술이나 방법은 나중에 습득하면 된다. 처음엔 아무 생각없이 @SpringBootTest로 통합으로 시작해도 무방하다.
- 정말 중요한 것은 무엇을 왜 테스트 하는지이다. 이것은 책이나 어디서든 쉽게 알려주지 않는다.
- 쉽게 배울 수 없다는 것은 specific 하지 않고 Abstract 하다는 것이다. 테스트 원칙이나 철학은 Abstract에 해당하고 Concrete, Specific은 실제 업무 환경에서 찾아야 한다.

따라서 나는 책이 지루해질 때까지 공부하고 실제로 실무에 테스트 코드를 도입해면서 배우기로 했다. 나중에 지식이 더 필요할 때 책을 읽으면 더 재밌을 것이다.

### 어떤 테스트를 도입할 것인가?
다양한 Scope의 테스트가 있고 어떤 테스트를 도입할 것인지에 대해서 고민이 되었지만 나는 우선 필요한 테스트를 도입하는 것이 좋겠다고 생각했다. 
- 우선 기능을 구현하면서 보다 작은 단위의 로직을 검증하기 위한 `단위테스트`가 필요했다. 
- 그리고 사용자 시나리오에 따라서 기능 작동을 검증할 `인수테스트`가 필요했다. 
  - 단 E2E의 UI는 포함하지 않고 API를 테스트 하려고 생각했다.
  - UI를 포함하지 않는 테스트를 `인수테스트`라고 부를 수 있을지 고민을 했지만 서버사이드 개발의 종단이 API이기 때문에 많은 사례들이 서버 사이드의 인수테스트를 API까지 테스트하고 있었다. 나는 이를 `서버사이드 인수테스트`라고 구분하면 좋겠다고 생각했다.  [[3월 우아한테크세미나] 우아한ATDD](https://www.youtube.com/watch?v=ITVpmjM4mUE) 

아래는 챗 지피티가 알려준 각 테스트의 차이다.


| **구분**       | **단위 테스트 (Unit Test)**   | **기능 테스트 (Functional Test)**            | **인수 테스트 (Acceptance Test)**                  |
|--------------|--------------------------|-----------------------------------------|-----------------------------------------------|
| **목적**       | 개별 메서드나 클래스의 동작을 검증      | 특정 기능(API나 모듈)이 설계된 대로 동작하는지 검증         | 시스템이 사용자 요구사항을 충족하는지 종합적으로 검증                 |
| **관점**       | 개발자 관점, 코드 수준에서 테스트      | 개발자 관점, 기능 단위로 테스트                      | 사용자 또는 비즈니스 관점, 시스템 전체 테스트                    |
| **테스트 범위**   | 단일 메서드, 클래스, 작은 단위의 모듈   | API, 서비스 등 개별 기능이나 모듈                   | 사용자 시나리오 기반의 전체 흐름(종단 간 테스트)                  |
| **테스트 대상**   | 코드의 개별 요소                | 하나의 기능(예: API 엔드포인트, 서비스 로직)            | 전체 시스템, 여러 기능 간의 상호작용, UI와 데이터 흐름 등           |
| **사용 도구**    | JUnit, Mockito 등         | MockMvc, RestAssured 등                  | RestAssured, Selenium 등(전체 흐름을 테스트하는 도구)      |
| **테스트 속도**   | 매우 빠름                    | 비교적 빠름                                  | 상대적으로 느림 (종단 간 테스트이기 때문에 더 복잡함)               |
| **의존성**      | 테스트 대상 클래스 외에는 의존하지 않음   | API나 모듈이 서로 어떻게 동작하는지 일부 의존성 있음         | 전체 시스템 의존 (데이터베이스, 외부 시스템 등 포함 가능)            |
| **실제 환경 반영** | 실제 환경을 반드시 반영하지 않음       | 일부 실제 환경 반영 가능(Mock 사용 가능)              | 실제 환경과 유사하게 테스트, 데이터베이스와 실제 네트워크 호출 가능        |
| **예시**       | 특정 계산 메서드가 두 숫자를 더하는지 검증 | API 엔드포인트가 올바르게 작동하고, 응답을 예상대로 반환하는지 검증 | 사용자가 로그인하고 상품을 장바구니에 추가한 후 결제까지 완료하는 시나리오 테스트 |


나는 기존의 프로젝트의 레거시들에 테스트 코드가 없기 때문에 현재 개발을 하고 있는 기능에 대해서 우선 API 인수 테스트를 도입하고 특별히 로직이 어렵고 복잡하고 검증이 필요한 경우 단위테스트를 도입하고자 했다.

우선 요구사항에 따라 작성된 API 유즈케이스 시나리오를 작성했고 해당 시나리오에 맞도록 인수테스트를 작성했다. 그리고 상대적으로 로직이 중요한 경우나 API 인수테스트 만으로는 로직의 안정성을 보장할 수 없는 복잡도가 높은 로직의 경우는 단위테스트를 작성하기로 했다.


### 테스트 도입하기 1: 테스트에 필요한 Application Properties로 분리하기
내가 맡은 프로젝트는 application.yml, application-local.yml, application-prod.yml, application-dev.yml 로 각 Stage 마다 설정파일을 구분하고 있다. 

application.yml은 기본으로 공통로드 되는 설정이며 application.yml에 Stage마다 spring.profiles.active={profileName}를 변경해서 다른 설정을 덮어 씌운다.  
보통 Docker로 서버를 올리기 때문에 각 인스턴스의 docker-compose.yml에 해당 설정 값을 변경해서 사용한다. 

 테스트용 설정파일은 src/test/resources/에 위치시킨다. 기본적으로 @SpringBootTest는 자동으로 application.properties 를 로드한다. 내가 쓰는 인텔리제이의 환경에서는 src/test/resources/application.properties 를 찾고 없으면 src/main/resources/application.properties 를 가져온다. 

 따라서 굳이 src/test/resources/ 에 프로퍼티 공통 프로퍼티 파일을 위치시키지 않고 application-test.properties 만 저장해두고 @SpringBootTest(properties = "spring.profiles.active=test")로 테스트용 프로퍼티 파일만 따로 불러오는 것이 좋을 수 있다.  
 이 경우 공통 프로퍼티는 src/main/resources/application.properties 의 전적인 책임으로 맡기고 테스트용 프로퍼티만 명시적으로 애노테이션에서 지정해두는 것으로 메인 공통 프로퍼티의 변경으로 인한 환경 변화를 즉시 테스트 환경에 적용 가능하다.

 만약 테스트 환경의 변화로 `src/main/resources/application.properties` 가 아닌 다른 것을 사용해야 한다면 `src/test/resources/application.properties` 를 새롭게 둘 수 있다. 이런 경우 main 프로퍼티의 변경이 즉시 테스트 환경에 반영되지 않으므로 주의해야한다. 따라서 꼭 구분해둘 것이 아니면 변경된 프로퍼티는 `src/test/resources/application-test.properties` 에 지정해 두는 것이 좋다고 생각한다. 

또한 `@ActiveProfile({profileName})` 을 사용하면 기본 프로퍼티 외 다른 프로퍼티파일을 로드할 수 있다. 하지만 이는 런타임에 애노테이션을 읽고 로드하므로 프로퍼티 변수인 `${spring.profiles.active}`에 값이 지정되지 않는다. 따라서 어플리케이션에서 해당 변수를 사용하여 스프링 빈 등의 configuration이나 초기화를 실행하는 경우 문제가 생길 수 있다. 따라서 이런 경우 테스트 환경구축을 위해서 처음부터 일반적인 운영이나 개발 서버의 동작환경인 `-Dspring.profiles.active` 과 유사하도록 `@SpringBootTest(properties = "spring.profiles.active=")` attribute 를 지정하는 것이 좋다고 생각한다.


> references
>> - [Override default Spring-Boot application.properties settings in Junit Test
](https://stackoverflow.com/questions/29669393/override-default-spring-boot-application-properties-settings-in-junit-test)
>> - [[Spring] @Profile, @ActiveProfiles 에 대해](https://bepoz-study-diary.tistory.com/371)
>> - [Baeldung - Spring Profiles](https://velog.io/@baekrang256/Baeldung-Spring-Profiles)

나는 위에서 공부한 내용을 바탕으로 환경변수 영역에서 실제 서비스 환경과 같은 테스트 환경을 구축했다.

###  테스트 도입하기 2: 테스트 데이터 베이스 환경 선택하기
흔히 데이터 베이스에 대해서 다음과 같은 2가지 방식 중 하나를 고른다.

| 항목           | 로컬 데이터베이스               | 컨테이너 기반 데이터베이스         |
|--------------|-------------------------|------------------------|
| **설치 및 설정**  | 개발자의 로컬 환경에 직접 설치       | Docker 등 컨테이너로 설정 자동화  |
| **환경 일관성**   | 개발자별 환경 차이 발생 가능        | 모든 환경에서 일관성 유지         |
| **속도**       | 설정이 되어 있다면 빠르게 실행 가능    | 컨테이너 생성 및 실행 시간 필요     |
| **자원 관리**    | 개발자 로컬 자원 사용            | 컨테이너에 할당된 자원만 사용       |
| **초기화 용이성**  | 데이터 초기화 및 리셋이 번거로울 수 있음 | 컨테이너 재실행으로 쉽게 초기화 가능   |
| **CI/CD 통합** | 별도의 설정 필요               | 쉽게 통합 가능, 자동화에 유리      |

나는 연습차원에서 둘을 모두 현제 프로젝트에 적용해 보았다. 테스트 컨테이너로 데이터베이스 환경을 구축하는 것은 뚜렷한 장점은 있지만 아직까지 꼭 필요한 기술은 아니었다. 또한 프로젝트의 현재 수준에서는 로컬 환경으로 테스트틑 해보는 것으로 충분했다. 나중에 필요하다면 컨테이너 기반으로 고도화를 할 수도 있을 것이다.

따라서 나는 테스트 데이터베이스 환경 구축을 로컬 데이터 베이스로 결정했다. 


### ??

나는 인수 테스트 코드 작성을 위해서 RestAssured를 도입하기로 했다.
RestAssured는 
