---
layout: post
title:  "이메일_중복검사는_정말_애플리케이션_서비스에서_해아하나"
date:   2024-00-00 00:00:00 +0900
categories: 
---
# 애플리케이션 서비스에서 도메인 서비스로: 도메인 제약조건 검증의 올바른 위치


나는 최근 도메인 주도 설계(DDD)를 적용하는 과정에서 엔티티 중복 검사 로직이 과연 어디에 위치해야 하는지에 대한 고민을 하게 되었다. 많은 프로젝트에서 이 검증 로직은 애플리케이션 서비스 계층에 위치하곤 한다. 하지만 이러한 설계가 과연 도메인 주도 설계의 관점에서 올바른 것인지 의문이 들었다.

## 도메인 제약조건, 그 위치에 대한 고민

대부분의 프로젝트에서 엔티티의 중복 검사는 애플리케이션 서비스에서 이루어진다. 전형적인 코드는 이런 모습이다:

```java
@Service
@RequiredArgsConstructor
public class MemberApplicationService {
    private final MemberRepository memberRepository;
    
    @Transactional
    public Long register(MemberRegisterCommand command) {
        // 중복 검사 로직이 애플리케이션 서비스에 위치
        if (memberRepository.existsByEmail(command.getEmail())) {
            throw new DuplicateEmailException(command.getEmail());
        }
        
        Member member = new Member(command.getName(), command.getEmail());
        memberRepository.save(member);
        return member.getId();
    }
}
```

이렇게 작성된 코드는 얼핏 보면 문제가 없어 보인다. 실제로 내가 현업에서 보던 코드도 대부분 이런 방식이다. 그러나 비즈니스 도메인의 관점에서 보면, '이메일은 중복될 수 없다'라는 규칙은 단순한 기술적 제약이 아닌 도메인의 핵심 규칙일 수 있다.

## 공구상자 정리하기: 도메인 서비스로의 이전

도메인 규칙은 도메인 계층에 있는 편이 자연스럽다. 따라서 엔티티 중복 검사와 같은 도메인 제약조건은 도메인 서비스로 이전하는 것을 고려했다.

```java
// 도메인 서비스
@Service
@RequiredArgsConstructor
public class MemberDomainService {
    private final MemberRepository memberRepository;
    
    public void validateEmailNotDuplicated(String email) {
        if (memberRepository.existsByEmail(email)) {
            throw new DomainException.DuplicateEmailException(email);
        }
    }
}

// 애플리케이션 서비스
@Service
@RequiredArgsConstructor
public class MemberApplicationService {
    private final MemberRepository memberRepository;
    private final MemberDomainService memberDomainService;
    
    @Transactional
    public Long register(MemberRegisterCommand command) {
        // 도메인 서비스를 통한 중복 검사
        memberDomainService.validateEmailNotDuplicated(command.getEmail());
        
        Member member = new Member(command.getName(), command.getEmail());
        memberRepository.save(member);
        return member.getId();
    }
}
```

이렇게 변경함으로써 얻는 이점은 분명하다. 도메인 규칙이 도메인 계층에 명확히 위치하게 되어 코드의 의도가 더 명확해진다. 또한 다른 서비스에서도 동일한 검증 로직을 쉽게 재사용할 수 있다. 

## 도메인 경계의 명확한 분리

나는 엔티티 중복 검사가 단순한 기술적 제약을 넘어 핵심 비즈니스 규칙인 경우가 많다고 생각한다. '이메일은 중복될 수 없다', '사용자명은 유일해야 한다', '주문번호는 중복될 수 없다' 등의 규칙은 비즈니스 도메인의 핵심 제약조건이다. 이를 도메인 서비스로 분리함으로써, 우리는 도메인 모델의 응집도를 높이고 애플리케이션 서비스는 오케스트레이션에 집중하게 할 수 있다.

## 실제 적용 사례

최근 나의 프로젝트에서는 회원 가입 시 이메일과 닉네임의 중복 검사를 담당하는 도메인 서비스를 구현했다:

```java
@Service
@RequiredArgsConstructor
public class MemberUniquenessValidator {
    private final MemberRepository memberRepository;
    
    public void validateUniqueEmail(String email) {
        if (memberRepository.existsByEmail(email)) {
            throw new MemberEmailAlreadyExistsException(email);
        }
    }
    
    public void validateUniqueNickname(String nickname) {
        if (memberRepository.existsByNickname(nickname)) {
            throw new MemberNicknameAlreadyExistsException(nickname);
        }
    }
}
```

이 도메인 서비스는 명확한 책임을 가지고 있으며, 여러 애플리케이션 서비스에서 재사용할 수 있다. 또한 이 접근 방식은 테스트하기도 용이하다. 단순히 도메인 서비스만 모킹하면 애플리케이션 서비스를 테스트할 수 있고, 도메인 서비스 자체의 테스트도 간결하게 작성할 수 있다.
# 그러나 고려 해야할 점
비지니스 규칙을 도메인 계층으로 옮긴다는 말은 무척 합리적으로 들리지만 실무적으로는 고려해야할 사항이 많다. 앞서 설명한 도메인 서비스나 중복검사기는 위치상으로는 도메인 서비스와 도메인엔티티 사이에 존재한다. 결국 로직의 흐름상 중간자적인 역할을 하는 것이고 엄밀히 말하자면 순수한 도메인 계층이라 하기 어렵다. 많은 DDD의 사례에서 리파지토리를 직접 사용하는 것은 애플리케이션 계층이라고 주장하기 때문에 도메인 서비스가 리파지토리를 주입받고 사용하는 순간 계층간 경계가 무너졌다고 생각될 수도 있다. 즉 도메인 계층의 오염 문제가 발생한다.

## 도메인 서비스가 리파지토리 주입을 받음으로 생기는 도메인 계층의 오염문제를 최소화하는 방법
분명 도메인 계층이 애플리케이션 계층으로부터 오염되는 것은 지양해야한다. 동시에 멤버의 이메일의 중복제약조건은 비지니스 규칙이라서 애플리케이션 서비스가 담당하게 하면 안된다. 이것을 어떻게 파훼할 수 있을까?
### 애그리거트 루트에게 작업을 위임하기
만약 어느 멤버 그룹에서 멤버의 이메일이 겹쳐서는 안된다는 비니지스 규칙이 있다면 멤버 그룹을 애그리거트 루트로 설정하고 하위 애그리거트인 멤버의 이메일을 검사하게 로직을 위임 할 수 있다. 단 애플리케이션에서 현실적으로 모든 하위 멤버를 조회해온다는 것이 현실적으로 가능한 상황에 한정된다. 예를 들어 멤버 그룹이 아니라 전체 멤버를 대상으로하는 규칙검사는 이 방식으로 할 수가 없다.

### 도메인 서비스가 주입받는 리파지토리를 최대한 순수하게 유지하기
다른 방식은 도메인 계층에 리파지토리 인터페이스를 두고 도메인 순수성을 가지도록 설계하는 것이다. 비지니스 로직이 계획되면 리파지토리는 그 비지니스 로직에만 쓰이는 방식으로 메서드를 구성한다. 멤버 이메일의 중복 검사에 필요한 조회 메서드의 시그니쳐를 정의하고 구현체에게 구현을 위임한다. 애플리케이션 서비스에서는 이 리파지토리를 직접 호출하지 않는다.

### 도메인 로직, 도메인 서비스를 통한 리파지토리 접근
위의 두 방식 외에 내가 최근에 적용하고 있는 또 다른 방식은 도메인 로직(Domain Logic)을 구성하는 것이다. 도메인 로직은 도메인 서비스와 함께 도메인 계층에 위치하며, 리파지토리와의 통신을 담당한다. 애플리케이션 서비스는 이 도메인 로직 계층을 통해 간접적으로 리파지토리에 접근한다.

다음은 이러한 방식의 구현 예시다. 코틀린을 사용했다.

```kotlin
// 도메인 로직 계층 - 엔티티 중복 검사를 위한 클래스
@Component
class MemberDuplicateChecker(private val memberRepository: MemberRepository) {
    fun checkDuplicationByEmail(email: String) {
        if (memberRepository.existsByEmail(email)) {
            throw MemberEmailAlreadyExistsException(email)
        }
    }
}

// 도메인 로직 계층 - 엔티티 저장을 위한 클래스
@Component
class MemberSaver(private val memberRepository: MemberRepository) {
    fun save(member: Member): Member {
        return memberRepository.save(member)
    }
}
```

이제 도메인 서비스는 도메인 로직 계층을 사용하여 리파지토리에 간접적으로 접근한다:

```kotlin
// 도메인 서비스
@Service
class MemberUniquenessValidator(private val memberDuplicateChecker: MemberDuplicateChecker) {
    
    fun validateUniqueEmail(email: String) {
        memberDuplicateChecker.checkDuplicationByEmail(email)
    }
}
```

마지막으로, 애플리케이션 서비스는 도메인 서비스를 호출한다:

```kotlin
@Service
class MemberApplicationService(
    private val memberSaver: MemberSaver,
    private val memberUniquenessValidator: MemberUniquenessValidator
) {
    
    @Transactional
    fun registerMember(name: String, email: String): Member {
        // 도메인 서비스를 통한 이메일 중복 검사
        memberUniquenessValidator.validateUniqueEmail(email)
        
        // 회원 생성 및 저장 - 도메인 로직 계층을 통해 간접적으로 접근
        val member = Member.createAsGuest(name)
        return memberSaver.save(member)
    }
}
```

이 접근법의 장점은 다음과 같다:

1. 도메인 서비스는 리파지토리에 직접 의존하지 않아 도메인 계층의 순수성을 더 유지할 수 있다.
2. 도메인 로직 계층은 단일 책임 원칙(SRP)을 따르는 작은 클래스들로 구성되어 있어 테스트와 유지보수가 용이하다.
3. 애플리케이션 서비스는 도메인 로직을 조합하는 역할에 집중할 수 있다.
4. 리파지토리 접근 패턴이 일관성을 가지게 되어 코드의 예측 가능성이 높아진다.

실제로 내가 작성한 OAuth2LoginService의 경우, 리파지토리를 직접 호출하는 대신 도메인 로직 계층을 통해 간접적으로 접근하게 된다:

```kotlin
@Service
class OAuth2LoginService(
    private val naverApiClient: NaverApiClient,
    private val socialMemberRegister: SocialMemberRegister,
    private val socialAccountFinder: SocialAccountFinder,
    private val memberFinder: MemberFinder,
    private val accessTokenManager: AccessTokenManager,
    private val refreshTokenManager: RefreshTokenManager
) {
    @Transactional
    fun loginNaver(code: String, state: String): AuthTokenDTO {
        // 네이버 인증토큰 발행
        val naverToken = naverApiClient.getAccessToken(code, state)
        // 인증 토큰으로 네이버 프로필 조회
        val naverProfile = naverApiClient.getProfile(naverToken.tokenType, naverToken.accessToken)
        // 소셜 아이디를 구함
        val socialAccountUid = SocialAccountUid(OAuth2Provider.NAVER, naverProfile.getId())
        // 소설 아이디로 서비스에 등록된 계정을 찾음 - 도메인 로직 계층을 통해 접근
        val socialAccount = socialAccountFinder.find(socialAccountUid)
        val member: Member =
            if (socialAccount == null) {
                //등록된 소셜 계정이 없는 경우 해당 소셜 아이디로 신규 멤버로 등록함
                val newGuestMember = Member.createAsGuest(naverProfile.getName())
                socialMemberRegister.registerNew(newGuestMember, socialAccountUid)
            } else {
                memberFinder.get(socialAccount.memberId)
            }
        // 대상 멤버로 액세스 토큰 발행
        val refreshTokenDTO = refreshTokenManager.make(member.uid)
        val refreshToken = RefreshToken(
            refreshTokenDTO.memberUid,
            refreshTokenDTO.issueAt,
            refreshTokenDTO.expiration
        )

        return AuthTokenDTO(
            accessTokenManager.make(member.uid),
            refreshTokenDTO
        )
    }
}
```

또한 `SocialMemberRegister` 도메인 서비스도 리파지토리를 직접 주입받지 않고 도메인 로직 계층을 통해 간접적으로 접근한다:

```kotlin
@Service
class SocialMemberRegister(
    private val memberDuplicateChecker: MemberDuplicateChecker,
    private val socialAccountDuplicateChecker: SocialAccountDuplicateChecker,
    private val memberSaver: MemberSaver,
    private val socialAccountSaver: SocialAccountSaver
) {
    fun registerNew(member: Member, socialAccountUid: SocialAccountUid): Member {
        // 중복 검사는 도메인 로직 계층을 통해 수행
        memberDuplicateChecker.checkDuplication(member.uid)
        socialAccountDuplicateChecker.checkDuplication(socialAccountUid)
        
        // 저장도 도메인 로직 계층을 통해 수행
        val savedMember = memberSaver.save(member)
        socialAccountSaver.save(SocialAccount(socialAccountUid, member.uid))
        
        return savedMember
    }
}
```

## 도메인 계층의 순수성과 현실적인 타협

도메인 계층의 순수성을 유지하는 것은 중요하지만, 현실적인 시스템 구현에서는 종종 타협이 필요하다. 나는 도메인 로직 계층을 추가함으로써 도메인 서비스와 리파지토리 사이의 간접 계층을 만들어 도메인 계층의 순수성을 높이고자 했다.

이 방식은 다음과 같은 장점이 있다:

1. **비지니스 규칙의 응집성**: 연관된 비지니스 규칙이 한 곳에 응집되어 있다.
2. **재사용성**: 도메인 로직 클래스들은 여러 서비스에서 쉽게 재사용할 수 있다.
3. **테스트 용이성**: 작은 책임을 가진 클래스들이므로 테스트하기 쉽다.
4. **순수성 향상**: 도메인 서비스는 리파지토리에 직접 의존하지 않는다.

물론 이 방식도 완벽하지 않다. 클래스 수가 증가하고 간접 계층이 늘어나는 단점이 있다. 하지만 도메인 규칙이 명확히 도메인 계층에 위치하면서도, 리파지토리 접근은 일관된 패턴을 통해 이루어진다는 장점이 더 크다고 생각한다.

최종적으로, 도메인 계층의 순수성과 실용성 사이에서 적절한 균형을 찾는 것이 중요하다. 모든 프로젝트와 팀마다 상황이 다르기 때문에, 이상적인 아키텍처보다는 현실적인 제약 조건과 요구사항에 맞게 적응하는 것이 필요하다.

도메인 로직 계층을 통한 리파지토리 접근 방식은 도메인 중심의 설계를 유지하면서도, 실제 시스템의 요구사항을 충족시키는 균형 잡힌 접근법이라 생각한다.